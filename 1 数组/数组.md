# 数组

### 什么是数组

从学术上来说 ，数组是一种**线性表**数据结构 ，用一组**连续的内存空间**来存储一组具有**相同类型**的数据 。

这句定义中有三个关键词需要注意 ，分别是 **线性表**、**连续的内存空间** 以及 **相同类型** 。

- **线性表**

**线性表**的一个最主要的特性就是线性表上的数据最多只有**前后**两个方向 ，也就是数据是排成一条线的 ，其他也是线性表结构的有 链表 ，队列 ，栈 。而**非线性表**，例如二叉树 、 堆 、图等的数据都不是简单的前后关系 。

- **连续的内存空间和相同类型的数据**

因为存储的数据时相同类型的，且同是连续存储 ，这也就意味着我们可以根据每个数据的大小和整个数据存储的起始位置 ，来计算每一个数据块的位置 。

```
a[i]_address = base_address + i * data_type_size
```

记住这个公式 ，在下面的问题中我们会用到 。

### 根据下标来进行随机访问

能直接计算每一个数据的位置，就实现了一个数组最重要的特性， **随机访问** ，数组可以根据下标在 O(1) 的时间访问需要的元素 ，这样就是为什么我们常说数组的优势在于查找 。

这里有一点需要注意 ，我们在区分链表和数组的时候往往会说 ，数组的优势在于查找 ，查找的时间复杂度是 O(1) ，链表优势在插入、删除 ，时间复杂度是 O(1) 。

这里的表述实际上存在一点小问题 ，数组是适合查找 ，但哪怕是排好序的数组 ，在使用二分查找的情况下的时间复杂度也是 O(logn) 。所以准确的表述是 ，数组支持随机访问 ，**根据下标**随机访问的时间复杂度为 O(1) 。

### 插入与删除之痛

我们都知道 ，为了保证数组内部数据的连续性 ，数组的插入和删除的效率是非常低的 ，那么是什么导致了数组的更改低效 ，又有什么改进方法呢 ？

先来说说**插入操作** 。

举个栗子 ，上体育课的时候 ，老师要求同学们按身高顺序从低到高排成一列队伍 ，在场的一共有 10 位学生 ，在排好队伍之后 ，一位迟到的学生要归队，他的身高在所有人里面拍第五 ，我们就需要将第五高以及之后的一共六位同学的位置向后移动一位 。

我们将这一段数据化一下 ，就是一个长度为 n 的已经排好序的数组 ，要在第 k 位插入一位数据 ，需要第 k 位到第 n 位的数据向后移一个数据长度 。

对插入操作进行复杂度分析 ，最好时间复杂度发生在数据插入位置为最后一位时 ，复杂度为 O(1) , 最坏时间复杂度发生在数据插入位置为第一位时 ，所有元素都需要进行移动 ，时间复杂度为 O(n) 。如果我们在每一个位置插入数据的概率是一样的 ，那么平均情况的时间复杂度就有 (1 + 2 + 3 + ... + n)/n = O(n) 。

再来说说**删除操作** 。

和插入操作一样的是 ，我么那为了保证数组是一个连续的内存空间 ，在删除第 k 位的情况下我们就需要对 k - n 位的数据进行迁移 ，保证中间没有空位 。

那么有没有什么方法可以一定程度上优化数组的这些问题呢 ？答案是有的 ：

对于插入操作来说 ，如果数组是无序的 ，那么将数据插入第 k 位最方便的方法就是将原本第 K 位的数据取出来放到最后 ，再把需要新加的这个数据放在第 K 位 。 

而对于删除操作来说 ，在某些特殊场景中，我们对于内存空间的连续性并没有那么高的要求 ，我们就可以将多次的删除操作先记录下来 。也就是说每次删除操作并不进行数据迁移 ，只是记录数据已被删除，在合适的时候一次性执行 ，这样的设计将会大幅度减少删除操作导致的数据迁移 。

如果你了解 JVM ，你会发现这就是 JVM 标记清除垃圾回收算法的核心思想 ，学习算法和数据结构的乐趣就在于此 ，我们并不是要死记硬背某个数据结构或者算法 ，而是要学习 ，了解背后的思想和处理技巧 ，你会发现在软件开发过程中处处都有着数据结构和算法的影子 。这也就是为什么我们说数据结构和算法是编程的基石 。

### 容器和数组

容器是我们在开发过程中经常使用到的对象 ，他把我们常用的数据结构进行了封装 ，将许多操作细节隐藏了起来以便于我们进行开发 ，这样在开发过程中我们可以更注重业务逻辑而不用操心数据结构的底层细节 。

例如容器是支持**动态扩容**的 ，例如我们在 Java 中使用 ArrayList ，我们就不用去关心底层扩容逻辑 ，ArrayList 会在每次存储空间不足时将空间自动扩容为 1.5 倍大小 。

不过需要注意一点 ，容器的扩容涉及到了内存申请以及数据搬迁 ，是比较耗时的 ，所以能事先取得定数据大小的数据一定要在创建容器的时候直接指定数据大小 。

容器看起来这么的完美 ，那么我们无脑选择容器不就好了吗 ？

其实并不是这样的 ，容器封装大量的方法 ，带来方便的同时也意味着容器所使用的空间大于直接实现的数组 ，并且 Java 的 ArrayList 无法存储基本数据类型 ，例如 int ，long 等数据都需要封装为 Integer 和 Long ，装箱和拆箱都会带来一定的性能损耗 ，在性能敏感的编程环境 ，例如网络通信下 ，就要选择数组 。

如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组 。

还有一个表示表示多维数组时，用数组往往会更加直观。比如 Object[][] array[ ] [ ]；而用容器的话则需要这样定义：ArrayList<ArrayList<object>> array。

总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一点的性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

### 总结

关于数组的特性到这里就差不多结束了 ，那么现在有一个问题需要我们来解答 。

“为什么大多数编程语言中 ，数据要从 0 开始编号而不是从 1 开始 ？”

从数据储存的内存模型上来看 ，“下标” 最准确的定义应该是 “偏移(offset)” 。也就是说 ，如果使用 a 来表示数组的首地址 ，那么 a[0] 代表的就是偏移为 0 的位置 ，也就是首地址 ， a[k] 表示偏移 k 个 type_size 的位置 ，所以计算 a[k] 的内存地址公式为

```
a[k]_address = base_address + k * type_size
```

如果数组从 1 开始计数 ，那么我们计算数组元素 a[k] 的内存地址就会变为 ：

```
a[k]_address = base_address + (k - 1) * type_size
```

可以到到如果数组从 1 开始计数 ，那么每次随机访问数组元素都多了一次减法运算 ，也就是多了一条减法指令 。

数组最为最基础的数据结构之一 ，通过下标随机访问数组又是数组的基础编程操作 ，那么对于这个操作的优化就要做到极致 。为了减少这一次的减法指令 ，数组选择了从 0 开始编号 ，而不是 1 。

当然 ，寻址优化并不一定是真正的原因 ，数组之所以从 0 开始编号 ，更大的可能是因为历史原因 ，最早 C 语言设计使用了 0 作为下标 ，之后的 Java ，JS 为了方便 C 语言开发者的学习 ，沿用了 C 语言的编号习惯 。同时我们也可以看到很多语言并不是从 0 开始计数的 ，例如 Matlab ，甚至还有支持负数下标的 ，例如 Python 。